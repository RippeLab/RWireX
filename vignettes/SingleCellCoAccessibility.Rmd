---
title: "Vignette for single cell co‚Äêaccessibility analysis with RWireX"
author: "Isabelle Seufert"
output: html_document
---
# Load libraries
library(ArchR)
library(plotgardener)
library(SpectralTAD)

library(RWireX)

# Load exemplary data


# Generate peak accessibility matrix
First, we generate the peak accessibility matrix. For now, we subset our peak set to reduce run time and required resources.

```{r}
### Only take peaks on chromosome 8
PeakSet <- PeakSet[seqnames(PeakSet) == "chr8"]

### Add peaks to ArchR project
proj <- addPeakSet(proj, peakSet = PeakSet)

### Generate peak accessibility matrix without binarizing the counts
proj <- addPeakMatrix(proj, binarize = FALSE)
```

# Compute single cell co-accessibility
Next, we compute single cell co-accessibility for each sample separately, as the samples represent cell from one TNFa treatment time point selected for a homogeneous population of cells in G1 cell cycle state. If you use your own data, you might want to consider selecting homogeneous cell clusters or cell types for separate analyses.

```{r}
scCoacc_list <- list()

for (sample in samples){
    cells <- rownames(proj@cellColData)[proj$Sample == sample];
    scCoacc_list[[sample]] <- RWireX::getCoAccessibility(proj, 
                                                         useMatrix = "PeakMatrix",
                                                         cellsToUse = cells,
                                                         maxDist = 1e+06, 
                                                         AggregationMethod = "single_cell_resolution",
                                                         log2Norm = FALSE,
                                                         returnLoops = TRUE)
}
```

# Compute background co-accessibility
We want to assess which of these co-accessible links are true-positive. Again, we compute the background co-accessibility for each sample separately.

```{r}
bgCoacc_list <- list()

for (sample in samples){
    cells <- rownames(proj@cellColData)[proj$Sample == sample];
    bgCoacc_list[[sample]] <- RWireX::getBackgroundCoAccessibility(proj, 
                                                                   useMatrix = "PeakMatrix",
                                                                   cellsToUse = cells,
                                                                   maxDist = 1e+06, 
                                                                   AggregationMethod = "single_cell_resolution",
                                                                   log2Norm = FALSE)
}
```

We can have a look at the distribution of background co-accessibility per sample and select appropriate cutoffs. We recommend using the 99th percentile of background co-accessibility as lower cutoff to filter for true-positive co-accessible links.
```{r}
p <- ggplot()

for (sample in samples){
    df <- rbind(bgCoacc_list[[sample]]$BackgroundCoAccessibility$featShuffle,
                bgCoacc_list[[sample]]$BackgroundCoAccessibility$cellShuffle)
    df$sample <- sample
    
    p <- p + geom_histogram(data = as.data.frame(df),
             aes(x = correlation, fill = sample), alpha = 0.5)
}

p
```

Have a look at the 99th percentile cutoffs from background co-accessibility for each sample.

```{r}
lapply(bgCoacc_list, function(x){round(x$BackgroundCutoff, 4)})
```

# Filter autonomous links of enriched co-accessibility (ACs)
We select high-confidence co-accessible links using a lower cutoff for correlation coefficients from the background distribution, a lower cutoff for percent accessible cells (frequency of link occurence in single cells) and only selecting links with positively correlated peak accessibility.

```{r}
AC_list <- list()

for (sample in samples){
    AC_list[[sample]] <- RWireX::filterCoAccessibility(coAccessibilityLoops = scCoacc_list[[sample]], 
                                                       corCutOff = bgCoacc_list[[sample]]$BackgroundCutoff, 
                                                       onlyPos = TRUE,
                                                       perAccess = 5)
}
```

Have a look at the number of ACs per sample.

```{r}
lapply(AC_list, function(x){length(x$CoAccessibility)})
```

# Visualize ACs by loops
We visualize ACs by loops. The color of loops reflects the correlation coefficient, while the height of loops reflects the frequency of the AC occurence in single cells. Here, we selected an exemplary region on chromosome 8 from our publication.

```{r}
AC_example <- as("chr8:102573784-102880000 ", "GRanges")

p <- RWireX::plotBrowserTrack(proj, 
                              region = AC_example,
                              groupBy = "Sample", 
                              normMethod = "nFrags", 
                              loops = lapply(AC_list, function(x){x$CoAccessibility}),
                              pal_loops = colorRampPalette(c("#f0f0f0", "black"))(100))
grid.newpage(); grid.draw(p)
```

# Compute AC activities per cell
Coming soon...

```{r}
AC_activities <- getLinkActivityMatrix(proj,
                                       AC_list$HUVEC_TNFa_0min_Rep1)
```

Visualize AC activities by heatmap.
```{r}
xx
```
